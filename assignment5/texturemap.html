<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>WebGL Assignment 5: Texture Mapping</title>
<script id="vs-fragment-lighting" type="x-shader/x-vertex">
attribute vec4 vPosition;
attribute vec4 vNormal;

// Model-View and Projection Parameters
uniform vec4 viewEye;
uniform vec4 viewAt;
uniform mat4 projectionMatrix;

// Instance Parameters
uniform float instanceScale;
uniform vec3 instanceRotation;
uniform vec3 instanceDisplacement;

// Light Parameters
uniform vec4 lightPosition1;
uniform vec4 lightPosition2;

// Fragment Lighting and Texturing
varying vec3 Nm, Nw, E;
varying float squareDistance1;
varying vec3 L1;
varying float squareDistance2;
varying vec3 L2;

// Computes a Model-View matrix representing a camera at a given eye-point,
// looking at a specified point, given a vector representing the upward direction.
mat4 lookAt(vec4 eye, vec4 at, vec3 up)
{
    vec3 e = eye.xyz / eye.w;
    vec3 a = at.xyz / at.w;
    if (e == a) return mat4(1.0);

    vec3 v = normalize(a - e);
    vec3 n = normalize(cross(v, up));
    vec3 u = normalize(cross(n, v));

    return mat4(n.x,          u.x,          -v.x,  0.0,
                n.y,          u.y,          -v.y,  0.0,
                n.z,          u.z,          -v.z,  0.0,
                -dot(n, e), -dot(u, e), dot(v, e), 1.0);
}

// Vertex Shader Entry Point
void main()
{
    // Compute the Scale factor of the Instance Transformation
    // (ALL Matrices specified in column-major order.)
    mat4 scale = mat4( instanceScale,  0.0,  0.0,  0.0,
                       0.0,  instanceScale,  0.0,  0.0,
                       0.0,  0.0,  instanceScale,  0.0,
                       0.0,  0.0,  0.0,  1.0 );

    // Compute the Rotation factor of the Instance Transformation
    vec3 instanceRotationCosine = cos(instanceRotation);
    vec3 instanceRotationSine = sin(instanceRotation);

    mat4 rx = mat4( 1.0,  0.0,  0.0, 0.0,
                    0.0,  instanceRotationCosine.x,  instanceRotationSine.x, 0.0,
                    0.0, -instanceRotationSine.x,  instanceRotationCosine.x, 0.0,
                    0.0,  0.0,  0.0, 1.0 );

    mat4 ry = mat4( instanceRotationCosine.y, 0.0, -instanceRotationSine.y, 0.0,
                    0.0, 1.0,  0.0, 0.0,
                    instanceRotationSine.y, 0.0,  instanceRotationCosine.y, 0.0,
                    0.0, 0.0,  0.0, 1.0 );


    mat4 rz = mat4( instanceRotationCosine.z, -instanceRotationSine.z, 0.0, 0.0,
                    instanceRotationSine.z,  instanceRotationCosine.z, 0.0, 0.0,
                    0.0,  0.0, 1.0, 0.0,
                    0.0,  0.0, 0.0, 1.0 );

    // Compute the Displacement factor of the Instance Transformation
    // (ALL Matrices specified in column-major order.)
    mat4 translation = mat4( 1.0,  0.0,  0.0,  0.0,
                             0.0,  1.0,  0.0,  0.0,
                             0.0,  0.0,  1.0,  0.0,
                             instanceDisplacement.x,  instanceDisplacement.y,  instanceDisplacement.z,  1.0 );

    // Calculate the Vertex Position and Normal in World Space
    // (Last specified, first applied.)
    vec4 worldPosition = translation
                       * rz * ry * rx
                       * scale
                       * vPosition;

    vec4 worldNormal = rz * ry * rx * vNormal;

    // Vector from Vertex to Light source (supporting directional light source)
    if (lightPosition1.w == 0.0)
    {
        squareDistance1 = 0.0;
        L1 = normalize(lightPosition1.xyz);
    }
    else
    {
        L1 = (lightPosition1.xyz / lightPosition1.w) - (worldPosition.xyz / worldPosition.w);
        squareDistance1 = dot(L1, L1);
        L1 = normalize(L1);
    }

    // Vector from Vertex to Light source (supporting directional light source)
    if (lightPosition2.w == 0.0)
    {
        squareDistance2 = 0.0;
        L2 = normalize(lightPosition2.xyz);
    }
    else
    {
        L2 = (lightPosition2.xyz / lightPosition2.w) - (worldPosition.xyz / worldPosition.w);
        squareDistance2 = dot(L2, L2);
        L2 = normalize(L2);
    }

    // Vector from Vertex to Viewer (eye)
    E = normalize((viewEye.xyz / viewEye.w) - (worldPosition.xyz / worldPosition.w));

    // Normal Vectors (model and world) at Vertex
    Nm = vNormal.xyz / vNormal.w;
    Nw = normalize(worldNormal.xyz);

    // Calculate the Model-View Matrix
    vec3 viewUp = vec3(0.0, 1.0, 0.0);
    mat4 modelViewMatrix = lookAt(viewEye, viewAt, viewUp);

    // Translate the World-Position to Clip Coordinates
    // (Last specified, first applied.)
    gl_Position = projectionMatrix * modelViewMatrix * worldPosition;
}
</script>
<script id="fs-fragment-lighting" type="x-shader/x-fragment">
precision mediump float;

#define M_PI 3.1415926535897932384626433832795
#define M_PI_2 1.57079632679489661923132169163975
#define M_2PI 6.283185307179586476925286766559

uniform sampler2D texture0;

// Fragment Lighting and Texturing
varying vec3 Nm, Nw, E;
varying float squareDistance1;
varying vec3 L1;
varying float squareDistance2;
varying vec3 L2;

// Options and Flags
uniform int blinnSpecular;
uniform int wireframe;
uniform int lightScene;
uniform int textureMappingMode;

// Light Parameters (Light 1)
uniform vec4 lightAmbient1;
uniform vec4 lightDiffuse1;
uniform vec4 lightSpecular1;
uniform vec3 lightAttenuation1;

// Light Parameters (Light 2)
uniform vec4 lightAmbient2;
uniform vec4 lightDiffuse2;
uniform vec4 lightSpecular2;
uniform vec3 lightAttenuation2;

// Material Parameters
uniform vec4 materialAmbient;
uniform vec4 materialDiffuse;
uniform vec4 materialSpecular;
uniform float materialShininess;

vec4 calculateLighting(float squareDistance, vec3 Nw, vec3 L, vec3 E,
                       int blinnSpecular,
                       vec4 lightAmbient, vec4 lightDiffuse, vec4 lightSpecular, vec3 lightAttenuation,
                       vec4 materialAmbient, vec4 materialDiffuse, vec4 materialSpecular, float materialShininess)
{
    // Phong's Ambient Component
    vec4 colour = lightAmbient * materialAmbient;

    // Add Diffuse and Specular light if the light source bounces off the surface
    // (Angle between L and Nw is not more than 90-degrees)
    float q = dot(L, Nw);
    if (q >= 0.0)
    {
        // Distance Fall-Off
        float attenuationDenominator = max(lightAttenuation[0] + lightAttenuation[1] * sqrt(squareDistance) + lightAttenuation[2] * squareDistance, 1.0);

        // Phong's Diffuse Component
        colour += (q * (lightDiffuse * materialDiffuse)) / attenuationDenominator;

        if (blinnSpecular == 0)
        {
            // Phong's Specular Component
            vec3 R = normalize(2.0 * q * Nw - L);
            colour += (pow(max(dot(E, R), 0.0), materialShininess) * (lightSpecular * materialSpecular)) / attenuationDenominator;
        }
        else
        {
            // Blinn's Specular Component
            vec3 H = normalize(L + E);
            colour += (pow(max(dot(Nw, H), 0.0), materialShininess) * (lightSpecular * materialSpecular)) / attenuationDenominator;
        }
    }

    // Set Reflected Light Alpha
    colour.a = 1.0;
    return colour;
}

// Coverts (x, y, z) to (radius, azimuth, inclination)
vec3 cartesianToSphericalCoordinates(vec3 p)
{
    float radius = sqrt((p.x * p.x) + (p.y * p.y) + (p.z * p.z));
    float azimuth = atan(p.y, p.x);
    float inclination = acos(p.z / radius);

    return vec3(radius, azimuth, inclination);
}

// Coverts (x, y, z, w) to (radius, azimuth, inclination)
vec3 cartesianToSphericalCoordinates(vec4 p)
{
    vec3 s = cartesianToSphericalCoordinates(p.xyz);
    s.r = s.r / p.w;
    return s;
}

void main()
{
    if (wireframe == 0)
    {
        // Texture the Fragment
        vec3 sphericalCoordinates = cartesianToSphericalCoordinates(Nm);
        vec2 textureCoordinates = sphericalCoordinates.yz;
        textureCoordinates.x = (M_PI + textureCoordinates.x) / M_2PI;
        textureCoordinates.y = textureCoordinates.y / M_PI;

        if (textureMappingMode == 1)
        {
            textureCoordinates.x = Nm.x / 0.5;
            textureCoordinates.y = Nm.y / 0.5;
        }
        else if (textureMappingMode == 2)
        {
            textureCoordinates.y = Nm.z / 0.5;
        }

        gl_FragColor = texture2D(texture0, textureCoordinates);

        if (lightScene != 0)
        {
            // Calculate Lighting
            vec4 colour1 = calculateLighting(squareDistance1, Nw, L1, E,
                                             blinnSpecular,
                                             lightAmbient1, lightDiffuse1, lightSpecular1, lightAttenuation1,
                                             materialAmbient, materialDiffuse, materialSpecular, materialShininess);

            vec4 colour2 = calculateLighting(squareDistance2, Nw, L2, E,
                                             blinnSpecular,
                                             lightAmbient2, lightDiffuse2, lightSpecular2, lightAttenuation2,
                                             materialAmbient, materialDiffuse, materialSpecular, materialShininess);

            gl_FragColor *= (colour1 + colour2);
        }
    }
    else gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
</script>
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="../Common/webgl-utils.js"></script>
<script type="text/javascript" src="../Common/initShaders.js"></script>
<script type="text/javascript" src="../Common/MV.js"></script>
<script type="text/javascript" src="texturemap.js"></script>
</head>
<body>
    <img id="earthTexture" src="images/earth.jpg" hidden></img>

    <canvas id="gl-canvas" width="512" height="512">
        Your browser does not support the HTML5 canvas element.
    </canvas>
    <div id="userControls">
        <div id="textureSelection">
            <div>
                <strong>Texture Types:</strong>
                <span>
                    <input type="radio" name="textureRadio" value="earth" checked="checked">Earth</input>
                    <input type="radio" name="textureRadio" value="checkerBoard">Checker Board</input>
                    <input type="radio" name="textureRadio" value="checkerBoard2">Checker Board 2</input>
                </span>
            </div>
            <div>
                <strong>Texture Maps:</strong>
                <span>
                    <input type="radio" name="textureMappingMode" value="spherical" checked="checked">Spherical</input>
                    <input type="radio" name="textureMappingMode" value="planar">Planar</input>
                    <input type="radio" name="textureMappingMode" value="cylindrical">Cylindrical</input>
                </span>
            </div>
        </div>

        <div id="lightingOptions">
            <div>
                <strong>Material Type:</strong>
                <span>
                    <input type="radio" name="specularRadio" value="blinn" checked="checked">Blinn</input>
                    <input type="radio" name="specularRadio" value="phong">Phong</input>
                </span>
            </div>
            <div>
                <strong>Light Sources:</strong>
                <span>
                    <input type="checkbox" name="light1Check" value="light1" checked="checked">Static</input>
                    <input type="checkbox" name="light2Check" value="light2" checked="checked">Orbital</input>
                </span>
            </div>
        </div>

        <div id="meshManipulation">
            <div>
                <strong>Scale:</strong>
                <input id="scaleRange" type="range" min="0.1" max="10.0" value="3.6" step="0.01">
            </div>
            <div>
                <strong>Rotation:</strong>
                X: <input id="rotationXRange" type="range" min="0.0" max="6.283" value="0.0" step="0.01">
                Y: <input id="rotationYRange" type="range" min="0.0" max="6.283" value="0.0" step="0.01">
                Z: <input id="rotationZRange" type="range" min="0.0" max="6.283" value="0.0" step="0.01">
            </div>
        </div>
        
        <div>
            <strong>Misc:</strong>
            <input type="checkbox" name="lightSceneCheck" value="lightScene" checked="checked">Light Scene</input>
            <input type="checkbox" name="wireframeCheck" value="wireframe">Wireframe</input>
        </div>
    </div>
</body>
</html>
